# 并行介绍
 * 引子  

> 忘掉那些该死的并行吧！ —— Linus Torvalds

  * 简介  
    Linux 大神说：忘掉那些该死的并行吧！但是我们别忘掉了他后面还有2句话，将他完整的话贴出来：
    
    **Where the hell do you envision that those magical parallel algorithms would be used? 
The only place where parallelism matters is in graphics or on the server side, where we already largely have it. Pushing it anywhere else is just pointless.**

 大概的意思是，除了在服务端和图像处理2个领域可以使用并行计算，并且确实有大量广泛的应用。其他领域并行计算毫无建树！
 
 * 术语
    * 临界区：共享资源
    * 阻塞/非阻塞：临界区是否等待的行为
    * 死锁：彼此占用资源是对方想要的
    * 饥饿：长久的等待
    * 活锁：“过度的谦让”，资源在2线程间跳动

* 2 大定律 
  >程序并行化比率和处理器之间的关系，即何种配置可以达到优化级大值,F为代码可以优化的比例，n为处理器个数。
   * 阿姆达尔定律（Amdahl）  
         * 优化前/优化后= 1/(F+(1-F)/n） 
   * 古斯塔夫森定律（Gustafson）
           * 优化前/优化后= n-F(n-1)

 总结：无可并行的程序，加速比就是1；全部是并行程序，加速比就是n。          
 
* JVM
> 虚拟机里面关键点技术为围绕着多线程的原子性、可见性、有序性来建立的。

* 原子性：操作是一个整体，即多个线程在一起执行的时候，操作一旦开始是不会被其他线程干扰的
* 可见性：共享变量的值改变了，对于其他线程是否立即可见
* 有序性：CPU 为了性能指令重排

可见性和有序性说明  

* 可见性：CPU为了提高读写性能，都有自己的2/3级缓存（若干寄存器），在工作时候首先是和自己的缓存交互，再刷新/读取值from主存（可以理解为主机的内存）。这样就会出现，在什么时机会刷新/读取from主存，多核的CPU怎么样才能保证自己的缓存值是最新的。
* 有序性：CPU会对程序的指令进行重排，目的是为了提高执行的速度，但是执行重排对于单线程来说是语意一致的，对于多线程来说不一定。
   * 指令重排 Happen-Before 原则  
      * 一个线程内保证语义是串行的
      * volatile规则，volatile 的写先与读
      * 锁规则，解锁先与加锁
      * 传递性，A先与B，B先与C，则A必然先与C
      * 线程的start方法，永远优先与线程里面其他动作
      * 线程的终结方法，永远晚于线程里其他操作
      * 线程中断先与被中断线程的代码
      * 对象的构造方法执行和结束，有先于finalize方法